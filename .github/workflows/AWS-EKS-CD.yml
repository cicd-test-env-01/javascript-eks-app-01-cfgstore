# ====================================================================================== #
#
#  Workflow : AWS EKS CD 파이프라인
#
#  Workflow 설명 :
#    - 어플리케이션의 Configuration을 Config Management 시스템으로 배포 (S3 업로드)
#    - EKS에 Kubernetes Manifests 적용 (POD 배포/재시작, 리소스 변경 등)
#
#  Workflow 상세 가이드 :
#    - https://lgu-cto.atlassian.net/wiki/spaces/CLOUDASSET/pages/37479319390/AWS-EKS+CI+CD+Workflow
#
#  버전 : v1.1
#
# ====================================================================================== #
name: AWS EKS CD 파이프라인

on:
  push:
    branches:
      - dev
      - qa
      - prod
    tags:
      - CONFIG*
    paths-ignore:
      - '.github/**'

env:
  AWS_REGION: ap-northeast-2
  CONFIG_REPO_YAML_DIR: aws-eks

jobs:
  # 1. CD 환경 확인
  #   - Workflow 트리거 유형에 따른 CD 환경 확인 및 설정
  #     : dev 브랜치 push = 개발 배포 용 CD
  #     : qa 브랜치 push = 검수 배포 용 CD
  #     : prod 브랜치 push + Commit 메세지에 "From Build" 또는 "Rollback To"포함 = 상용 배포 용 CD
  #        * QA_PM 및 QA_Admin 승인 포함
  #        * Commit 메세지에 "From Build"/"Rollback To"가 없을 경우 배포 진행 안되며 배포 필요 시 CONFIG* Release(Tag)를 생성하여 진행
  #     : CONFIG_QA Release(Tag) 생성 = 상용 배포 용 CD
  #        * QA_PM 및 QA_Admin 승인 포함
  #     : CONFIG_IT Release(Tag) 생성 = 상용 배포 용 CD
  #        * IT_Admin 승인 포함
  env-set:
    name: 1. CD 환경 확인
    runs-on: ubuntu-latest
    outputs:
      cd-env: ${{ steps.cd-env-set.outputs.cd-env }}

    steps:
    - name: Config Repository Checkout
      uses: actions/checkout@v3

    - name: DEV 배포
      if: github.ref_name == 'dev'
      run: |
        echo "DEPLOY_ENV=dev" >> $GITHUB_ENV

    - name: QA 배포
      if: github.ref_name == 'qa'
      run: |
        echo "DEPLOY_ENV=qa" >> $GITHUB_ENV

    - name: PROD 배포
      if: github.ref_name == 'prod'
      run: |
        COMMIT_MSG=`git log --format=%B -n 1 ${{ github.event.after }}`
        FROM_BUILD=`echo ${COMMIT_MSG} | grep "From Build" | wc -l`
        FROM_ROLLBACK=`echo ${COMMIT_MSG} | grep "Rollback To" | wc -l`

        if [[ ${FROM_BUILD} == "1" || ${FROM_ROLLBACK} == "1" ]]
        then
          echo "DEPLOY_ENV=prod_from_build" >> $GITHUB_ENV
        else
          echo "DEPLOY_ENV=prod_skip_deploy" >> $GITHUB_ENV
        fi

    - name: PROD Config 배포
      if: startsWith(github.ref_name, 'CONFIG')
      run: |
        if [ -z ${{ github.event.base_ref }} ]
        then
          BASE_REF=none
        else
          BASE_REF=${{ github.event.base_ref }}
        fi
        
        if [[ ${BASE_REF} != "refs/heads/prod" ]]
        then
          echo "PROD가 아닌 다른 브랜치에서 Tag 생성됨"
          exit 1
        fi

        CONFIG_QA=`echo ${{ github.ref_name }} | grep CONFIG_QA | wc -l`
        CONFIG_IT=`echo ${{ github.ref_name }} | grep CONFIG_IT | wc -l`
        
        if [[ ${CONFIG_QA} == "1" ]]
        then
          echo "DEPLOY_ENV=prod_qa" >> $GITHUB_ENV
        elif [[ ${CONFIG_IT} == "1" ]]
        then
          echo "DEPLOY_ENV=prod_it" >> $GITHUB_ENV
        else
          exit 1
        fi

    - name: CD 환경 설정
      id: cd-env-set
      run: echo "::set-output name=cd-env::${DEPLOY_ENV}"

  # 2.1 QA PM 승인
  QA-PM-approval:
    name: (PROD) 2.1 QA PM 승인
    needs: env-set
    if: |
      needs.env-set.outputs.cd-env == 'prod_from_build' ||
      needs.env-set.outputs.cd-env == 'prod_qa'
    runs-on: ubuntu-latest
    environment: QA-PM

    steps:
    - name: QA PM 승인
      run: echo "QA PM 승인 완료"

  # 2.2 QA Admin 승인
  QA-Admin-approval:
    name: (PROD) 2.2 QA Admin 승인 - 배포 진행
    needs: QA-PM-approval
    runs-on: ubuntu-latest
    environment: QA-Admin

    steps:
    - name: QA Admin 승인
      run: echo "QA Admin 승인 완료"
        
  # 2. IT Admin 승인
  IT-Admin-approval:
    name: (PROD) 2. IT Admin 승인 - 배포 진행
    needs: env-set
    if: |
      needs.env-set.outputs.cd-env == 'prod_it'
    runs-on: ubuntu-latest
    environment: IT-Admin
    
    steps:
    - name: IT Admin 승인
      run: echo "IT Admin 승인"
      
  # 3. Configuration 배포 대상 확인
  #    - configuration 폴더가 존재할 경우 -> Configuration S3 배포 수행
  #    - configuration 폴더가 없을 경우 -> Config 배포 Skip 후 Kubernetes 배포 진행
  check-config:
    name: 3. 배포 대상 확인
    if: |
      always() &&
      needs.env-set.outputs.cd-env != 'prod_skip_deploy' &&
      contains(join(needs.env-set.result, ','), 'success') &&
      !contains(join(needs.QA-PM-approval.result, ','), 'failure') && !contains(join(needs.QA-PM-approval.result, ','), 'cancelled') &&
      !contains(join(needs.QA-Admin-approval.result, ','), 'failure') && !contains(join(needs.QA-Admin-approval.result, ','), 'cancelled') &&
      !contains(join(needs.IT-Admin-approval.result, ','), 'failure') && !contains(join(needs.IT-Admin-approval.result, ','), 'cancelled')
    needs: [env-set, QA-PM-approval, QA-Admin-approval, IT-Admin-approval]
    outputs:
      config_flag: ${{ steps.check_files.outputs.config_flag }}
    runs-on: ubuntu-latest
    steps:
    - name: Config Repositoy Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 2

    - name: Commit 변경 파일 확인
      id: check_files
      run: |
        echo "========== Configuration 폴더 확인 =========="
        CONFIG_CNT=`ls -l | grep configuration | wc -l`
        if [[ ${CONFIG_CNT} != 0 ]]
        then
          CONFIG_FLAG=true
        else
          CONFIG_FLAG=false
        fi
        echo "Configuration 폴더 존재 : "${CONFIG_FLAG}
        echo "::set-output name=config_flag::${CONFIG_FLAG}"

  # 4. Config 배포
  #  - configuration 폴더가 존재할 경우 배포
  #  - Trigger 된 Commit에 파일 변경이 없더라도 배포 진행
  app-config-deploy:
    name: 4. Config 배포
    needs: [env-set, check-config]
    if: |
      always() &&
      needs.env-set.outputs.cd-env != 'prod_skip_deploy' &&
      needs.check-config.outputs.config_flag == 'true' &&
      contains(join(needs.check-config.result, ','), 'success')
    runs-on: ubuntu-latest

    steps: 
    - name: AWS Credentials 설정
      run: |
        if [[ ${{ needs.env-set.outputs.cd-env }} == "dev" ]]
        then
          echo "DEPLOY_ENV=dev" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.DEV_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
        elif [[ ${{ needs.env-set.outputs.cd-env }} == "qa" ]]
        then
          echo "DEPLOY_ENV=qa" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.QA_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.QA_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV        
        elif [[ ${{ needs.env-set.outputs.cd-env }} == "prod"* ]]
        then
          echo "DEPLOY_ENV=prod" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.PROD_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
        else
          exit 1
        fi

    - name: Config Repository Checkout
      uses: actions/checkout@v3

    - name: AWS Credentials 설정
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Config 파일 AWS S3 Bucket으로 복사
      run: |
        ORGA_NAME=`echo ${{ github.repository_owner }} | tr "[:upper:]" "[:lower:]"`

        if [[ ${ORGA_NAME} == "ucmp-dev-work-org" || ${ORGA_NAME} == "ucmp-prod-work-org" ]]
        then
          ORGA_NAME=`echo ${{ secrets.ORGA_NAME }} | tr "[:upper:]" "[:lower:]"`
        fi

        S3_CONFIG_BUCKET=`echo s3-${DEPLOY_ENV}-${ORGA_NAME}-app-cfgstore`
        
        aws s3 cp ./configuration/${DEPLOY_ENV}-config s3://${S3_CONFIG_BUCKET}/configuration/${DEPLOY_ENV}-config --recursive

  # 5. EKS 배포
  kubectl-apply:
    name: 5. EKS 배포
    needs: [env-set, app-config-deploy]
    if: |
      always() &&
      needs.env-set.outputs.cd-env != 'prod_skip_deploy' &&
      contains(join(needs.check-config.result, ','), 'success') &&
      !contains(join(needs.app-config-deploy.result, ','), 'failure')
    runs-on: ubuntu-latest

    steps:
    - name: AWS 변수 설정
      run: |
        if [[ ${{ needs.env-set.outputs.cd-env }} == "dev" ]]
        then
          echo "DEPLOY_ENV=dev" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.DEV_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER=${{ secrets.DEV_EKS_CLUSTER_NAME }}" >> $GITHUB_ENV
        elif [[ ${{ needs.env-set.outputs.cd-env }} == "qa" ]]
        then
          echo "DEPLOY_ENV=qa" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.QA_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.QA_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER=${{ secrets.QA_EKS_CLUSTER_NAME }}" >> $GITHUB_ENV
        elif [[ ${{ needs.env-set.outputs.cd-env }} == "prod"* ]]
        then
          echo "DEPLOY_ENV=prod" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.PROD_AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "EKS_CLUSTER=${{ secrets.PROD_EKS_CLUSTER_NAME }}" >> $GITHUB_ENV
        else
          exit 1
        fi
  
    - name: Config Repository Checkout
      uses: actions/checkout@v3

    - name: AWS Credentials 설정
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: EKS 클러스터 접속 Kubeconfig 설정
      run: |
        aws eks --region ${{ env.AWS_REGION }} update-kubeconfig --name ${EKS_CLUSTER}
        echo "NAMESPACE=`yq eval ".metadata.name" ./${{ env.CONFIG_REPO_YAML_DIR }}/${DEPLOY_ENV}-yaml/namespace.yaml`" >> $GITHUB_ENV
        echo "DEPLOYMENT=`yq eval ".metadata.name" ./${{ env.CONFIG_REPO_YAML_DIR }}/${DEPLOY_ENV}-yaml/deployment.yaml`" >> $GITHUB_ENV

    - name: EKS 배포 - kubectl apply
      run: |-
        echo "=== Kubectl Apply ==="
        cd ${{ env.CONFIG_REPO_YAML_DIR }}/${DEPLOY_ENV}-yaml
        kustomize build . | kubectl apply -k ./
        
    - name: EKS 배포 - Deployment Rollout Restart
      if: needs.env-set.outputs.cd-env != 'prod_from_build'
      run: |-
        echo "=== Kubectl Rollout Restart ==="
        kubectl rollout restart deployment/${DEPLOYMENT} -n ${NAMESPACE}

    - name: Deployment Rollout 상태 확인
      run: |-
        echo "=== Kubectl Rollout Status ==="
        kubectl rollout status deployment/${DEPLOYMENT} -n ${NAMESPACE}

    - name: 리소스 최종 상태 확인
      if: always()
      run: |-
        cd ${{ env.CONFIG_REPO_YAML_DIR }}/${DEPLOY_ENV}-yaml
        MNFT_LIST=`ls -l | awk '{ print $9 }' | grep -v "kustomization"`
        for manifest in `echo ${MNFT_LIST}`
        do
          KIND_LIST=`yq eval ".kind" ${manifest} | grep -v "\---" | uniq`
          for kind in ${KIND_LIST}
          do
            echo "==== ${kind} ==="
            kubectl get `echo ${kind} | tr "[:upper:]" "[:lower:]"` -o wide -n ${NAMESPACE}
            echo ""
          done
        done
        echo "==== Pods ==="
        kubectl get pods -o wide -n ${NAMESPACE}

  # 6. 소스 코드 빌드 Commit에 DEPLOY 성공 Tag 추가
  add_tag_to_src:
    name: 6. PROD 배포 - 소스 빌드 Commit에 DEPLOYED Tag 생성
    needs: [check-config, kubectl-apply]
    if: |
      always() &&
      needs.env-set.outputs.cd-env == 'prod_from_build' &&
      contains(join(needs.kubectl-apply.result, ','), 'success')
    runs-on: ubuntu-latest

    steps:
    - name: Config Repository Checkout
      uses: actions/checkout@v3
      with:
        path: config-repo

    - name: DEPLOY / ROLLBACK 확인
      working-directory: config-repo
      run: |
        COMMIT_MSG=`git log --format=%B -n 1 ${{ github.event.after }}`
        FROM_BUILD=`echo ${COMMIT_MSG} | grep "From Build" | wc -l`
        FROM_ROLLBACK=`echo ${COMMIT_MSG} | grep "Rollback To" | wc -l`

        if [[ ${FROM_BUILD} == "1" ]]
        then
          echo "TYPE_PREFIX=DEPLOYED" >> $GITHUB_ENV
        elif [[ ${FROM_ROLLBACK} == "1" ]]
        then
          echo "TYPE_PREFIX=ROLLBACK" >> $GITHUB_ENV
        else
          echo ${COMMIT_MSG}
          echo "From Build or Rollback To Missing"
          exit 1
        fi

    - name: 배포 Commit 난수 생성 (Short Commit HASH)
      run: |
        echo "SHORT_SHA=`echo ${{ github.sha }} | cut -c1-8`" >> $GITHUB_ENV

    - name: 소스 코드 Repository 변수 설정
      run: |
        echo "SRC_COMMIT=`sed -n '1,1p' ./config-repo/source_commit-id.dat`" >> $GITHUB_ENV
        echo "SRC_TAG=`sed -n '2,2p' ./config-repo/source_commit-id.dat`" >> $GITHUB_ENV
        echo "TARGET_REPO=`echo ${{ github.repository }} | awk -F "-cfgstore" '{ print $1 }'`" >> $GITHUB_ENV

    - name: 소스 코드 Repository Checkout
      uses: actions/checkout@v3
      with:
        path: source-repo
        repository: ${{ env.TARGET_REPO }}
        ref: ${{ env.SRC_COMMIT }}
        token: ${{ secrets.GHP_TOKEN }}

    - name: 소스 코드 Repo로 배포 완료 Tag Push
      working-directory: source-repo
      run: |
        REPO_NAME=`echo ${GITHUB_REPOSITORY} | awk -F / '{ print $2 }'`
        git config --global user.name cd.${REPO_NAME}
        git config --global user.email cd.${REPO_NAME}@lguplus.co.kr
        git tag -a ${TYPE_PREFIX}_${SRC_TAG}_${SHORT_SHA} ${SRC_COMMIT} -m "PROD Deploy Successful Tag"
        git push origin ${TYPE_PREFIX}_${SRC_TAG}_${SHORT_SHA}
